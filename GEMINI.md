# ESP32-RTSPServer Project Maintenance Document

This document was generated by Gemini Code Assist to provide developers and maintainers of the `ESP32-RTSPServer` project with a clear and comprehensive technical reference. It aims to facilitate understanding of the project's architecture, features, and future development.

## 1. Project Overview

`ESP32-RTSPServer` is an Arduino library specifically designed for the ESP32 microcontroller. Its core function is to create an RTSP (Real-Time Streaming Protocol) server for streaming video, audio, and subtitle data. The library simplifies the process of setting up a multimedia streaming server on an ESP32, supporting various transport protocols and client connections.

## 2. Core Features

- **Multimedia Streaming**:
  - **Video**: Captures and streams video from ESP32 camera modules (e.g., OV2460).
  - **Audio**: Captures and streams audio from sources like microphones via the I2S interface.
  - **Subtitles**: Supports sending text-based subtitle data.
- **Multiple Transport Protocols**:
  - **UDP (Unicast/Multicast)**: Efficient but unreliable transport, suitable for low-latency scenarios.
  - **TCP**: Reliable transport that guarantees data integrity, though with potentially higher latency.
  - **HTTP Tunneling**: Encapsulates RTSP/RTP data within HTTP requests to traverse firewalls.
- **Client Management**:
  - **Multi-client Support**: Natively supports multiple clients in Multicast mode. The `OVERRIDE_RTSP_SINGLE_CLIENT_MODE` macro enables multi-client support for all transport modes.
  - **Authentication**: Supports setting a username and password for RTSP Basic Authentication to enhance security.
- **Highly Configurable**:
  - Allows for extensive parameter configuration at both compile-time and runtime.

## 3. Technical Architecture Analysis

The project's architecture is built around the `RTSPServer` class and leverages FreeRTOS for concurrent task handling to ensure stable data streams.

### 3.1 Multi-tasking Model

The project relies heavily on FreeRTOS's multi-tasking capabilities to handle concurrent operations, which is a core aspect of its design.

- **Main Task (RTSP Server Task)**: The `RTSPServer` library internally creates a task to listen for and handle client RTSP requests (e.g., DESCRIBE, SETUP, PLAY, TEARDOWN).
- **Data Sending Tasks**: The example code (in `README.md`'s `Usage` section) clearly demonstrates creating separate tasks for sending video, audio, and subtitles:
  - `sendVideo` Task: Loops to get frames from the camera and calls `rtspServer.sendRTSPFrame()` to send them.
  - `sendAudio` Task: Loops to read audio data from an I2S microphone and calls `rtspServer.sendRTSPAudio()`.
  - `sendSubtitles` Task: Loops to generate subtitle information and calls `rtspServer.sendRTSPSubtitles()`.

This decoupled design pattern is crucial. It prevents any single data source (like waiting for a camera frame) from blocking the sending of other data streams or the processing of RTSP control commands.

### 3.2 Data Flow

1.  **Initialization**:
    - The user's code initializes hardware like WiFi, camera, and I2S.
    - An instance of `RTSPServer` is created and configured (port, transport type, authentication, etc.).
    - `rtspServer.begin()` is called to start the RTSP server, which begins listening on the specified port.
2.  **Client Connection**:
    - An RTSP client (like VLC) connects to the ESP32's RTSP port.
    - The `RTSPServer` handles the client's `SETUP` request, negotiating the transport protocol (UDP/TCP) and ports.
3.  **Data Transmission**:
    - The `sendVideo`/`sendAudio` tasks in the user's code are triggered.
    - The task first calls `rtspServer.readyToSendFrame()` or `rtspServer.readyToSendAudio()` to check if the server is ready to receive data (i.e., if there is a connected client in the 'PLAYING' state).
    - If ready, the task acquires data from the hardware (camera/microphone).
    - It then calls `rtspServer.sendRTSPFrame()` / `sendRTSPAudio()` to hand the data to the library.
    - The `RTSPServer` library internally packetizes the raw data (e.g., a JPEG frame) into RFC-compliant RTP packets and sends them to the client over the negotiated UDP or TCP channel.

### 3.3 Key Files and Directories

- `src/`: Contains all the core source code of the library.
  - `ESP32-RTSPServer.h`: The main header file, defining the `RTSPServer` class and related enumerations.
  - `ESP32-RTSPServer.cpp`: The implementation of the `RTSPServer` class, containing RTSP command handling and RTP packetization logic.
- `README.md`: The project's primary documentation, including feature descriptions, usage examples, and an API list.
- `RTSPConfig.h` (User-provided): A file that users can create in their own sketch to override the library's default compile-time configurations.

## 4. Configuration & Customization

### 4.1 Compile-time Configuration

You can modify the library's default behavior by creating an `RTSPConfig.h` file in the root directory of your project (sketch).

```cpp
// RTSPConfig.h
#ifndef RTSP_CONFIG_H
#define RTSP_CONFIG_H

// Enable logging, which adds about 7.7KB to the Flash size. Used for debugging.
// #define RTSP_LOGGING_ENABLED

// Allow multiple clients to connect in all transport modes (TCP/UDP), not just multicast.
// #define OVERRIDE_RTSP_SINGLE_CLIENT_MODE

// Create a separate, non-blocking task for the video stream.
// #define RTSP_VIDEO_NONBLOCK

#endif // RTSP_CONFIG_H
```

### 4.2 Runtime Configuration

Before calling `rtspServer.begin()`, you can customize the server's behavior by setting the public member variables of the `RTSPServer` object.

**Example:**
```cpp
// Create an instance
RTSPServer rtspServer;

// --- Method 1: Set member variables before starting ---
rtspServer.transport = RTSPServer::VIDEO_AUDIO_SUBTITLES; // Set transport type
rtspServer.sampleRate = 48000;                           // Set audio sample rate
rtspServer.rtspPort = 8554;                              // Set RTSP port
rtspServer.setCredentials("user", "pass");               // Set authentication credentials
rtspServer.begin();

// --- Method 2: Pass parameters in the begin() call ---
rtspServer.begin(RTSPServer::VIDEO_ONLY, 554);
```

## 5. API Reference (Key APIs with English Descriptions)

### 5.1 Main Methods

| Method | Description |
| :--- | :--- |
| `RTSPServer()` | Constructor, creates an RTSPServer instance. |
| `bool begin(...)` | Initializes and starts the RTSP server. Can accept transport type, port, sample rate, etc., as parameters. Returns `true` on success. |
| `void deinit()` | Stops and releases RTSP server resources. |
| `void setCredentials(user, pass)` | Sets the username and password for RTSP Basic Authentication. |
| `void sendRTSPFrame(...)` | Sends a video frame. The library will packetize it into RTP packets. |
| `void sendRTSPAudio(...)` | Sends a segment of audio data. |
| `void sendRTSPSubtitles(...)` | Sends subtitle data. |
| `bool readyToSendFrame()` | Checks if the server is ready to send a video frame (i.e., a client is playing). Call before `sendRTSPFrame`. |
| `bool readyToSendAudio()` | Checks if the server is ready to send audio data. |
| `bool readyToSendSubtitles()` | Checks if the server is ready to send subtitle data. |
| `void startSubtitlesTimer(...)` | Starts a 1-second periodic timer to send subtitles, which can replace the `sendSubtitles` task. |

### 5.2 Main Public Variables

| Variable | Type | Description |
| :--- | :--- | :--- |
| `rtpFps` | `uint32_t` | **[Read-only]** The current video frame rate (FPS). |
| `transport` | `TransportType` | Sets the media type to be transported, e.g., `VIDEO_ONLY`, `VIDEO_AUDIO`. |
| `sampleRate` | `uint32_t` | The sample rate (in Hz) for the audio stream. |
| `rtspPort` | `int` | The port the RTSP server listens on, defaults to 554. |
| `rtpIp` | `IPAddress` | The destination IP address for Multicast mode. |
| `rtpTTL` | `uint8_t` | The Time-To-Live for RTP packets, used for multicast. |
| `rtpVideoPort` | `uint16_t` | The port for video RTP data. |
| `rtpAudioPort` | `uint16_t` | The port for audio RTP data. |
| `rtpSubtitlesPort` | `uint16_t` | The port for subtitle RTP data. |
| `maxRTSPClients` | `uint8_t` | The maximum number of clients allowed in multicast mode. |

## 6. Maintenance & Debugging Suggestions

1.  **Enable Logging**: When debugging connection issues or functional anomalies, the first step should be to uncomment `#define RTSP_LOGGING_ENABLED` in `RTSPConfig.h`. This will output detailed RTSP command interactions and internal state information via `Serial`.

2.  **Task Monitoring**: Since the system uses multiple FreeRTOS tasks, pay attention to the following when adding new features or modifying existing logic:
    - **Stack Size**: Use `uxTaskGetStackHighWaterMark()` to monitor the stack usage of each task to prevent stack overflows, which can cause system crashes. The example task stack sizes in `README.md` (e.g., `1024 * 5`) are a good starting point.
    - **Task Priority**: Ensure that the data sending tasks have a lower priority than the core RTSP server task to guarantee responsiveness to control commands.

3.  **Performance Benchmarking**: The `README.md` provides performance test results on specific hardware (OV2460 on ESP32-S3). After modifying image processing, encoding, or network sending logic, you should re-run performance tests to ensure that frame rate and stability have not degraded.

4.  **Client Compatibility**: Always test with standard RTSP clients like VLC and FFmpeg/ffplay to ensure maximum compatibility. VLC's logging feature (`Tools -> Messages`) is very helpful for analyzing client-server interaction issues.

5.  **Dependency Management**: The project depends on a specific version of the `ESP32 Arduino core` (>= 3.1.1). After updating the core version, regression testing is necessary to ensure all functionalities remain intact.
